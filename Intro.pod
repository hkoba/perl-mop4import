=head1 NAME

MOP4Import::Intro - Meta Object Protocol for Import

=head1 SYNOPSIS

Define your exporter like following:

  ### Define MyExporter with help of MOP4Import::Declare.
  package MyExporter {
    use MOP4Import::Declare -as_base;
    use MOP4Import::Util qw/globref/;
    
    sub declare_foo {
      my ($myPack, $opts, $callpack) = @_;
      # then add some method
      *{globref($callpack, 'foo')} = sub (@) { join("! ", "FOOOOOO", @_) };
    }
    
    sub declare_bar {
      my ($myPack, $opts, $callpack, $x, $y, @z) = @_;
      my $glob = globref($callpack, 'bar');
      *$glob = \ $x;
      *$glob = +{bar => $y};
      *$glob = \@z;
    }
  
    sub declare_say {
      my ($myPack, $opts, $callpack) = @_;
      require feature;
      feature->import('say');
    }
  };

Then use MyExporter in your class like following:

  ### Import MyExporter into your class MyApp.
  package MyApp;
  use MyExporter -say, -foo, [bar => "A", "x", 1..3];
  
  # Above means you called:
  #  use strict;
  #  use warnings;
  #  MyExporter->declare_say($opts, 'MyApp');
  #  MyExporter->declare_foo($opts, 'MyApp');
  #  MyExporter->declare_bar($opts, 'MyApp', "A", "x", 1..3);
  
  say foo bar => 3;
  
  say "scalar=$bar\t", "hash=$bar{bar}\t", "array=@bar";


  ### Create inner class MyApp::Artist and MyApp::CD using MOP4Import::Types.
  use MOP4Import::Types
    (Artist => [[fields => qw/artistid name/]]
     , CD   => [[fields => qw/cdid artistid title year/]]);
  
  my $dbh = sqlite_connect(shift);
  {
    my $sth = prepare_execute($dbh, "select * from artist");
    while (my Artist $artist = $sth->fetchrow_hashref) {
      say $artist->{name}
    }
  }
  
  {
    my $sth = prepare_execute($dbh, "select * from CD");
    while (my CD $cd = $sth->fetchrow_hashref) {
      say $cd->{title}
    }
  }
  
  # Used in above example.
  sub sqlite_connect {
    my ($dsn) = @_;
    require DBI;
    DBI->connect('dbi:SQLite:'.($dsn || ':memory:'));
  }
  
  sub prepare_execute {
    my ($dbh, $query, @params) = @_;
    my $sth = $dbh->prepare($query);
    $sth->execute(@params);
    $sth
  }


=head1 DESCRIPTION

MOP4Import, I propose here, is a set of (experimental) protocols
(and their dispatcher implementation) to write Exporter modules
in some B<extensible> ways.

=head1 MODULES

=head2 MOP4Import::Declare

L<MOP4Import::Declare> protocol dispatcher basically maps each
C<import()> arguments to method calls starting with B<declare_...>.
Typicall use of MOP4Import::Declare is like following:

  use MOP4Import::Declare -as_base, [fields => qw/foo bar/];

Above means basically:

  BEGIN {
    require MOP4Import::Declare;
    
    MOP4Import::Declare->declare_as_base(+{}, __PACKAGE__);
    
    MOP4Import::Declare->declare_fields(+{}, __PACKAGE__, qw/foo bar/);
  }

These methods are called I<MOP4Import declaration pragma>,
or simply I<pragma>. This module also provides some useful pragmas
like C<-as_base>, C<< [fields => qw/foo bar/] >> .. shown above
and serves as a base for other MOP4Import dispatchers.

=head2 MOP4Import::Types

L<MOP4Import::Types> is another style of protocol dispatcher.
This helps defining many B<inner classes> at once like following:

  package MyApp;
  use MOP4Import::Types
    T1 => [pragma, pragma..],
    T2 => [pragma,...];

Above means basically:

  package MyApp;
  sub T1 () {'MyApp::T1'}
  package MyApp::T1 {
    use MOP4Import::Declare pragma, pragma..;
  }
  sub T2 () {'MyApp::T2'}
  package MyApp::T2 {
    use MOP4Import::Declare pragma, ...;
  }

=head2 MOP4Import::Util

L<MOP4Import::Util> provides several functions to handle GLOBs 
and C<%FIELDS> such as C<globref($class,$name)>, C<fields_hash($class)> ...

=head1 SAMPLES

=head2 MOP4Import::Base::Configure

L<MOP4Import::Base::Configure> is a base class for Object Orientation.
To use this as a base class, simply:

  use MOP4Import::Base::Configure -as_base;

This class is designed to fully utilize B<statically checked> L<fields>.
L<fields> getters are automatically generated for public fields.
To set fields values, C<< $obj->configure(key => value, key2 => value2...) >>.
You can have set-hook as C<onconfigure_key($value)>.

Also there is its variant L<MOP4Import::Base::CLI>, which is designed for
Command Line applications.

=head2 MOP4Import::PSGIEnv

L<MOP4Import::PSGIEnv> provides B<static checking> for L<PSGI> ENV.
You can also declare your extension to PSGI Env.

  use MOP4Import::PSGIEnv qw/mypsgi.extension/;
  
  return sub {
    (my Env $env) = @_;
    return [200, [], ["PATH_INFO is ", $env->{PATH_INFO}
  		    , extension => $env->{'mypsgi.extension'}
  		  ]];
  }


=head1 AUTHOR

KOBAYASHI, Hiroaki E<lt>hkoba@cpan.orgE<gt>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
